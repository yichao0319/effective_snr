##########
## Project:
2012 
Mobile Adaptive Streaming over HTTP


##########
## 
The program analyzes CSI data collected by USRP2 running rawOFDM.
It includes the following parts:
1. parser:   two programs which read binary file generated by rawOFDM and print readable values
2. analyzer: the main program which analyze the collected CSIs.
3. plot: plot formula and measured relationship between EVM, SNR, BER


##########
## RawOFDM
I use the following commands to collect CSIs:
  i) ofdm: just transmit complex values (no padding, FEC, interleaving, ...)
    sudo ./ofdm_tx.py -f 2.4e9 -v -s 50 --amp=0.5
    sudo ./ofdm_rx.py -f 2.4e9 -v -s 50 --rxdata RXDATA --snrdata SNRDATA --snrmode 3 --rx-gain 30

  ii) qam: the complete ofdm, includes padding, FEC, interleaving, ...
    sudo ../qam_tx.py -v --outfile OUTFILE -s 50 --bitrate=1
    sudo ../qam_rx.py -v --infile OUTFILE -s 50 --bitrate=1 --rxdata RXDATA --berdata=BERDATA

    sudo ../qam_tx.py -v -f 2.4e9 -s 50 --bitrate=1
    sudo ../qam_rx.py -v -f 2.4e9 -s 50 --bitrate=1 --rxdata RXDATA --berdata=BERDATA

  iii) ofdm again. Send the frame with 96 ofdm symbol which includes BPSK, QPSK, QAM16, and 64QAM.
    matlab -r 'generate_tx_data'
    sudo ../ofdm_tx.py -v -f 2.4e9 --txdata=tx_syms.dat -N 1000 -s 96
    sudo ../ofdm_rx.py -v -f 2.4e9 --rxdata=rx_syms.dat -s 96
    ./parse.complex rx_syms.dat > rx_syms_plane.dat
  
- Note that I implement "snrmode 3" in RawOFDM which reports SNR for all symbols.
- The tips to install RawOFDM written by Apurv is also attached in the end of this README.


##########
## parser
1. parse_snr.cc
read float values from a binary file and print them on STDOUT.

2. parse.symbols.cc
read complex values from a binary file and print them on STDOUT.


e.g.
  parse.symbols RXDATA.s96
  parse.snr SNRDATA.s96


or run in the batch script:
  perl batch.parse.pl


##########
## analyzer: analyze traces collected from "ofdm" sending QPSK symbols
analyze_csi.m

e.g.
  analyze_csi('RXDATA.s96.pdat', 'SNRDATA.s96.pdat');

or run in the batch script:
  matlab -r 'batch_analyze_csi;'

or use condor:
  condor_submit batch_analyze_csi.condor

or use batch condor script:
  perl batch_analyze_csi_condor.pl


##########
## simulator: 
##   analyze traces collected from "ofdm" sending BPSK, QPSK, 16QAM, 64QAM symbols.
##   simulate the rate adaptation process
sim_rate_adaption.m



##########
## plot
plot_relationship.m
plot the formula

plot_evm_snr_ber_conversion.m
plot the measured EVM, SNR, and BER


##########
## RawOFDM installation guide

-- apurv --
This document details about installing and getting started to work with RawOFDM. The original page is here:
http://people.csail.mit.edu/szym/rawofdm/README.html

However, at the time of the above instructions, gnuradio was at 3.3.0 stage and eth driver was being used for 
USRP2. The instructions below detail the changes required to get the RawOFDM to work with
- gnuradio 3.5.0 
- UHD driver

If you want to run a version past 3.5.0, it might required a few other changes, since the automake functionality
was changed from 3.6.0 onwards. 

Pre-requisites
--------------
gnuradio 3.5.0
UHD 

Installing RawOFDM
------------------
1. Download and extract the package from http://people.csail.mit.edu/szym/rawofdm/rawofdm.tgz
   wget http://people.csail.mit.edu/szym/rawofdm/rawofdm.tgz
   tar -xvf rawofdm.tgz
   cd rawofdm

2. RawOFDM leverages the gr-howto-write-a-block example. 
   wget http://gnuradio.org/releases/gnuradio/gr-howto-write-a-block-3.3.0.tar.gz
   tar -xvf gr-howto-write-a-block-3.3.0.tar.gz

3. ./makelinks.sh gr-howto-write-a-block-3.3.0
   ./bootstrap

4. For all the Makefile.am that exist in rawofdm that have the following line:
   libraw_ofdm_la_LIBADD = \
        $(GNURADIO_CORE_LA)
    
   change to:
   libraw_ofdm_la_LIBADD = \
        $(GNURADIO_CORE_LA) \
    $(GR_DIGITAL_LA)

5. ./configure
   This should run without problems. If it doesn't - then figure out/let me know!

6. For all the Makefiles generated that have the following line:
   LIBS =  -L/usr/local/lib -lboost_thread-mt -lboost_date_time-mt -lgnuradio-core ... 
   
   add gnuradio-digital as well, such that
   LIBS =  -L/usr/local/lib -lboost_thread-mt -lboost_date_time-mt -lgnuradio-core -lgnuradio-digital ...

6.1 

rawOFDM/Makefile.common

for the variable:
  STD_DEFINES_AND_INCLUDES = \
        $(DEFINES) \                                                                                        
        -I$(abs_top_srcdir)/lib \                                                                           
        -I$(GNURADIO_CORE_INCLUDEDIR) \                                                                     
        -I$(GNURADIO_CORE_INCLUDEDIR)/swig

add one more path for swig
  STD_DEFINES_AND_INCLUDES = \
        $(DEFINES) \                                                                                        
        -I$(abs_top_srcdir)/lib \                                                                           
        -I$(GNURADIO_CORE_INCLUDEDIR) \                                                                     
        -I$(GNURADIO_CORE_INCLUDEDIR)/swig \
        -I/usr/local/include/gruel/swig

6.2
src/python/raw_ofdm_mod.py

add digital_swig library:
  from gnuradio.digital import digital_swig

the following two functions are in digital_swig:
  gr.ofdm_insert_preamble  ----->  digital_swig.ofdm_insert_preamble
  gr.ofdm_cyclic_prefixer  ----->  digital_swig.ofdm_cyclic_prefixer


6.3
src/python/qa_qam.py

add digital_swig library:
  from gnuradio.digital import digital_swig

the following function is in digital_swig:
  digital_swig.binary_slicer_fb()


6.4
src/lib/qam/raw_crc.h
src/lib/qam/raw_crc.cc

replace gr_crc32 by digital_crc32:
  gr_crc32 -> digital_crc32

6.5
for some machines, if the following error occurs:
<Error: bad register name `%dil'>

then modify:
src/lib/spiral/parity.h

line 8,   __asm__ __volatile__ ("test %1,%1;setpo %0" : "=g"(x) : "r" (x));
change to __asm__ __volatile__ ("test %1,%1;setpo %0" : "=q"(x) : "q" (x));


7. make; sudo make install
8. make check
   All the tests should pass - if not, then something has gone wrong!


Post-installation notes
----------------------
Assuming everything went alright, now you have the RawOFDM installed correctly. However, it still uses
the old 'eth' driver for usrp2, which needs to be replaced with UHD (if you are using UHD, which btw is 
"highly" recommended!)
cp $(GNURADIO_3.5.0_SRC)/gr-digital/examples/ofdm/uhd_interface.py $(RAWOFDM_SRC)/examples
cd $(RAWOFDM_SRC)/examples
in ofdm_tx.py comment all references/usage to usrp2. Add the following instead:

###import usrp2                 # comment out
from uhd_interface import uhd_transmitter   # add

####u = usrp2.sink(options)         # comment out
u = uhd_transmitter(options.args,       # add
                    options.bandwidth,
                    options.tx_freq, options.tx_gain,
                    options.spec, options.antenna,
                    options.verbose)

####if options.freq is not None:        # comment out
if options.tx_freq is not None:         # add 

#####usrp2.add_options(normal)          # comment out

add the following in def main(), search for the line: 
expert_grp = parser.add_option_group("Expert")
uhd_transmitter.add_options(parser)     # add this below the above

Make similar changes in ofdm_rx.py. If you want to use qam_rx.py/qam_tx.py, make similar changes. 
In the rx versions of xx_rx.py, use the uhd_receiver instead, and use appropriate parameters, like rx_freq, etc.


Pointers
--------
1. Depending on what options you use, some of the parameters might have to be changed. For instance I had to 
change the corr threshold from 0.7f to 0.5f in src/lib/raw_ofdm_frame_acquisition.cc on line 281. 

2. A good way to start is to use the qam_tx.py/rx.py which sends digital layer on top of the raw samples. This helps to 
see better on what is received correctly and so on. You can change the data in qam_tx.py (make_data) if it helps you 
to visualize the received information better at the receiver.

I'm still exploring RawOFDM, and depending on what you use, there might be some loose connections in the flowgraphs 
that might need to be patched up. Try fixing them yourself - this will help in you understanding the code, if not - 
then get back to me and we can work together on that. 




Again, please read the paper: http://groups.winnforum.org/d/do/1860 for a better understanding on how RawOFDM works - 
it is built on top of gnuradio ofdm blocks. Treat any software as a blackbox at your own peril! 



apurvb@cs.utexas.edu
